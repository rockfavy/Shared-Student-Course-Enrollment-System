# Student Course Enrollment System â€“ Security & Validation Documentation
---

# 1. Overview

Security and validation architecture for the API, covering authentication, authorization, secure data handling, multi-layer validation, and workflow/state integrity rules.

These controls ensure that only authorized users interact with the system and that all submitted data is accurate, consistent, and compliant with enrollment rules.

---

# 2. Authentication

## 2.1 Local Environment Authentication
Local environment uses **JWT Bearer authentication with symmetric key**.

- Symmetric key validation
- Local development identity management
- No external identity provider required

## 2.2 Production Environment Authentication
Production environment uses **Entra ID (Azure AD)**.

- Entra ID (Azure AD) identity provider
- Enterprise identity management

All environments use token-based authentication (JWT) with claims issued by their respective identity providers. Claims determine enrollment access.  

---

# 3. Authorization

## 3.1 Claims-Based Authorization
Authorization uses ASP.NET Core policies.

Common claims:
- `CanRegister`  
- `CanLogin`  
- `CanBrowseCourses`  
- `CanEnroll`  
- `CanViewOwnEnrollments`  
- `CanDeregister`  
- `CanManageCourses` (Admin)  

## 3.2 Enforcement Locations
Authorization is enforced:

1. **Endpoint-level** via `RequireAuthorization()`  
2. **Business logic** for sensitive operations  
3. **Resource-level** for student-specific data  

## 3.3 Access Outcomes
Unauthorized access must result in:
- HTTP **401 Unauthorized** for authentication failures, or  
- HTTP **403 Forbidden** for authorization failures  

---

# 4. Data Protection

## 4.1 Sensitive Data Categories
Sensitive categories include:
- Student passwords (hashed)  
- Student email addresses  
- Student personal information  
- Enrollment records  

## 4.2 Storage Security
- Passwords must be hashed before storage  
- No secrets in source control  
- All secrets stored in configuration (Key Vault for production)  
- Database connection strings secured  

---

# 5. Validation Architecture

Validation occurs at **multiple layers**:

1. DTO-level (DataAnnotations)  
2. Endpoint-level (business rules)  
3. Database-level (constraints)  

---

## 5.1 DTO-Level Validation
Handled via:
- DataAnnotations  
- FluentValidation (if used)  
- Model binding validation  

Examples:
- Required fields  
- Email format  
- String lengths  
- Numeric ranges  

```csharp
public record RegisterRequest(
    [Required] string FirstName,
    [Required] string LastName,
    [Required, EmailAddress] string Email,
    [Required, MinLength(8)] string Password
);
```

---

## 5.2 Endpoint-Level Validation
Business rule validation:

- Duplicate email check  
- Duplicate enrollment prevention  
- Course existence validation  
- Student ownership validation  

```csharp
public static void MapRegister(this IEndpointRouteBuilder app)
{
    app.MapPost("/register", async (
        RegisterRequest request,
        EnrollmentContext db) =>
    {
        // Validate email uniqueness
        if (await db.Students.AnyAsync(s => s.Email == request.Email))
        {
            return Results.BadRequest("Email already registered");
        }
        
        // Create student
        // ...
    });
}
```

---

## 5.3 Database-Level Validation
EF Core constraints:

- Unique constraints (email)  
- Required fields  
- Foreign key constraints  
- Index constraints  

---

# 6. Input Sanitization

## 6.1 Input Cleaning
- Trim whitespace from strings  
- Validate email format  
- Sanitize user input  
- Prevent SQL injection (EF Core handles this)  

## 6.2 Output Encoding
- JSON responses are automatically encoded  
- No HTML injection risks in API responses  

---

# 7. Password Security

## 7.1 Password Hashing
- Use secure hashing algorithm (BCrypt, Argon2, etc.)  
- Never store plain text passwords  
- Never return password hashes in responses  

## 7.2 Password Requirements
- Minimum length (e.g., 8 characters)  
- Complexity requirements (if applicable)  
- Password strength validation  

---

# 8. Token Security

## 8.1 Token Generation
- Tokens must include student ID  
- Tokens must include claims  
- Tokens must have expiration  

## 8.2 Token Validation
- Validate token signature  
- Validate token expiration  
- Validate token claims  

---

# 9. API Security Best Practices

## 9.1 HTTPS
- All API communication must use HTTPS  
- HTTP should redirect to HTTPS  

## 9.2 CORS
- Configure CORS appropriately  
- Allow only trusted origins  
- Restrict methods and headers  

## 9.3 Rate Limiting
- Consider rate limiting for authentication endpoints  
- Prevent brute force attacks  

---

# 10. Error Handling Security

## 10.1 Error Messages
- Error messages must not expose sensitive information  
- Generic error messages for authentication failures  
- Detailed errors only for validation (not security)  

## 10.2 Logging
- Log security-relevant events  
- Do not log sensitive data (passwords, tokens)  
- Use structured logging  

---

# 11. Validation Error Responses

## 11.1 Error Format
Use Problem Details (RFC 7807):

```json
{
  "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "One or more validation errors occurred",
  "status": 400,
  "errors": {
    "Email": ["Email is required", "Email format is invalid"]
  }
}
```

## 11.2 Validation Response
- Return all validation errors  
- Group errors by field  
- Provide clear error messages  

---

# 12. Security Headers

## 12.1 Recommended Headers
- Content-Security-Policy  
- X-Content-Type-Options  
- X-Frame-Options  
- Strict-Transport-Security  

---

# 13. Testing Security

## 13.1 Security Testing
- Test authentication failures  
- Test authorization failures  
- Test input validation  
- Test SQL injection prevention  
- Test XSS prevention  

---

# 14. Compliance Considerations

## 14.1 Data Privacy
- Handle student data responsibly  
- Follow data protection regulations  
- Implement data retention policies (if applicable)  

---

